# SIP通信系统问题排查与解决方案

## 项目概述
基于JAIN-SIP和JavaFX的即时通信系统，支持音视频通话、消息传输和群组功能。

---

## 问题1：一对一通话无法建立（408超时）

### 🔍 问题表现
```
发送INVITE到 alice
收到响应: 100
收到响应: 408  ← Request Timeout
对话终止
```

### 🎯 问题原因
**Kamailio位置注册表缓存了错误的客户端地址**

详细分析：
1. 客户端注册时，Kamailio检测到的源IP为`172.17.0.1`（Docker/WSL网络）
2. 但客户端实际监听在`10.129.161.35:随机端口`
3. Kamailio尝试将INVITE转发到错误的地址，导致被叫方收不到请求
4. 30秒后超时，返回408错误

### ✅ 解决方案

**方法1：重启Kamailio清除注册缓存**
```bash
# Docker环境
docker restart kamailio

# 系统服务
sudo systemctl restart kamailio
```

**方法2：等待注册过期**
- 默认注册有效期3600秒（1小时）
- 等待过期后自动重新注册

**方法3：修改Kamailio配置（长期方案）**
```
# 在kamailio.cfg中添加
modparam("nathelper", "received_avp", "$avp(received)")
```

### 📝 预防措施
1. 每次网络环境变化后重启Kamailio
2. 客户端重启后确保完全注册成功
3. 保持客户端持续运行，避免频繁启停

---

## 问题2：视频通话端口错误（发送到端口0）

### 🔍 问题表现
```
RTP视频发送错误: Can't send to port 0
```

### 🎯 问题原因
**对方SDP中视频端口为0，表示拒绝视频**

可能原因：
1. Linphone客户端未启用视频功能
2. 对方明确拒绝视频协商
3. SDP解析失败

### ✅ 解决方案

**修改`MediaManager.java`添加端口检测：**

```java
public void startVideoStream(String remoteSdp) {
    System.out.println("启动视频流...");
    
    try {
        String remoteIp = parseSdpIp(remoteSdp);
        int remoteVideoPort = parseSdpVideoPort(remoteSdp);
        
        // 检查对方是否接受视频
        if (remoteVideoPort == 0) {
            System.err.println("⚠️ 对方拒绝或不支持视频，跳过视频流启动");
            return;
        }
        
        // ... 正常启动视频流
    }
}
```

**修改`parseSdpVideoPort`添加详细日志：**

```java
private int parseSdpVideoPort(String sdp) {
    String[] lines = sdp.split("\r\n");
    for (String line : lines) {
        if (line.startsWith("m=video ")) {
            String[] parts = line.split(" ");
            if (parts.length >= 2) {
                try {
                    int port = Integer.parseInt(parts[1]);
                    if (port == 0) {
                        System.err.println("⚠️ 警告: SDP中视频端口为0，对方可能拒绝了视频");
                        return 0;
                    }
                    return port;
                } catch (NumberFormatException e) {
                    System.err.println("❌ 解析视频端口失败: " + parts[1]);
                }
            }
        }
    }
    System.err.println("⚠️ 警告: SDP中未找到视频行");
    return 0;
}
```

---

## 问题3：群组通话RTP端口冲突

### 🔍 问题表现
```
❌ 启动音频流失败: Address already in use: bind
java.net.BindException: Address already in use: bind
```

### 🎯 问题原因
**多个MediaManager实例使用相同的RTP端口**

在群组通话中：
1. 每个参与者需要独立的MediaManager
2. 原实现使用随机端口，但可能产生重复
3. 同一客户端需要管理多个音视频流

### ✅ 解决方案（已撤销，但记录供参考）

**方法1：全局端口计数器**
```java
public class MediaManager {
    private static int portCounter = 0; // 全局计数器
    
    public MediaManager() {
        synchronized (MediaManager.class) {
            localAudioPort = ClientConfig.RTP_PORT_START + (portCounter * 4);
            localVideoPort = localAudioPort + 2;
            portCounter++;
            
            // 防止端口超出范围
            if (localAudioPort > ClientConfig.RTP_PORT_START + 10000) {
                portCounter = 0;
                localAudioPort = ClientConfig.RTP_PORT_START;
                localVideoPort = localAudioPort + 2;
            }
        }
    }
}
```

**方法2：端口重试机制**
```java
public RtpAudioReceiver(int localPort) throws Exception {
    int maxRetries = 10;
    int currentPort = localPort;
    DatagramSocket tempSocket = null;
    
    for (int i = 0; i < maxRetries; i++) {
        try {
            tempSocket = new DatagramSocket(currentPort);
            System.out.println("✅ 成功绑定音频接收端口: " + currentPort);
            break;
        } catch (java.net.BindException e) {
            System.err.println("⚠️ 端口 " + currentPort + " 已被占用，尝试下一个端口...");
            currentPort += 2;
            if (i == maxRetries - 1) {
                throw new Exception("无法找到可用的音频接收端口", e);
            }
        }
    }
    this.socket = tempSocket;
}
```

---

## 问题4：数据库表名冲突

### 🔍 问题表现
```
SQLSyntaxErrorException: You have an error in your SQL syntax near 'groups'
```

### 🎯 问题原因
**`groups`是MySQL保留关键字**

### ✅ 解决方案

**在所有SQL语句中使用反引号：**

```java
@Select("SELECT * FROM `groups` WHERE id = #{id}")
Group getGroupById(Long id);

@Select("SELECT g.* FROM `groups` g INNER JOIN group_members gm ON g.id = gm.group_id WHERE gm.user_id = #{userId}")
List<Group> getUserGroups(Long userId);

@Insert("INSERT INTO `groups` (group_name, creator_id, description) VALUES (#{groupName}, #{creatorId}, #{description})")
@Options(useGeneratedKeys = true, keyProperty = "id")
void insertGroup(Group group);
```

---

## 问题5：LocalDateTime序列化错误

### 🔍 问题表现
```
com.google.gson.JsonIOException: Failed making field 'java.time.LocalDateTime#date' accessible
```

### 🎯 问题原因
**Gson默认不支持Java 8的LocalDateTime序列化**

### ✅ 解决方案

**创建GsonUtil工具类：**

```java
public class GsonUtil {
    private static final Gson gson;
    
    static {
        gson = new GsonBuilder()
            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
            .create();
    }
    
    public static Gson getGson() {
        return gson;
    }
    
    private static class LocalDateTimeAdapter extends TypeAdapter<LocalDateTime> {
        private static final DateTimeFormatter formatter = 
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        
        @Override
        public void write(JsonWriter out, LocalDateTime value) throws IOException {
            if (value == null) {
                out.nullValue();
            } else {
                out.value(value.format(formatter));
            }
        }
        
        @Override
        public LocalDateTime read(JsonReader in) throws IOException {
            if (in.peek() == JsonToken.NULL) {
                in.nextNull();
                return null;
            }
            return LocalDateTime.parse(in.nextString(), formatter);
        }
    }
}
```

**在HttpClientService中使用：**
```java
private static final Gson gson = GsonUtil.getGson();
```

---

## 问题6：文件上传响应解析错误

### 🔍 问题表现
```
Expected a string but was BEGIN_OBJECT
```

### 🎯 问题原因
**服务器返回的是对象而不是字符串**

服务器返回：
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "url": "/uploads/xxx.png"
  }
}
```

客户端期望：
```java
ApiResponse<String> response
```

### ✅ 解决方案

**修改返回类型：**
```java
public static ApiResponse<Map<String, String>> uploadFile(File file) {
    // ...
    return gson.fromJson(responseBody, 
        new TypeToken<ApiResponse<Map<String, String>>>(){}.getType());
}
```

**提取URL：**
```java
ApiResponse<Map<String, String>> response = HttpClientService.uploadFile(file);
if (response.isSuccess() && response.getData() != null) {
    String fileUrl = response.getData().get("url");
    // 使用fileUrl
}
```

---

## 问题7：摄像头占用冲突

### 🔍 问题表现
```
WebcamLockException: Webcam USB2.0 HD UVC WebCam 0 has already been locked
```

### 🎯 问题原因
**上一次通话后摄像头未正确释放**

### ✅ 解决方案

**在MediaManager.stopStreams()中强制关闭摄像头：**

```java
public void stopStreams() {
    System.out.println("停止所有媒体流...");
    
    // 停止音频
    if (audioSender != null) audioSender.stop();
    if (audioReceiver != null) audioReceiver.stop();
    
    // 停止视频
    if (videoSender != null) videoSender.stop();
    if (videoReceiver != null) videoReceiver.stop();
    
    // 强制关闭所有摄像头
    for (Webcam webcam : Webcam.getWebcams()) {
        if (webcam.isOpen()) {
            try {
                webcam.close();
                System.out.println("✅ 强制关闭摄像头: " + webcam.getName());
            } catch (Exception e) {
                System.err.println("⚠️ 关闭摄像头失败: " + e.getMessage());
            }
        }
    }
    
    System.out.println("✅ 所有媒体流已停止");
}
```

---

## 通用排查流程

### 1. 检查Kamailio状态
```bash
# Docker环境
docker ps | grep kamailio
docker logs kamailio

# 系统服务
sudo systemctl status kamailio
```

### 2. 检查客户端注册
查看SIP日志文件：
- `siplog_alice.txt`
- `sipserver_alice.txt`

关键内容：
```
REGISTER sip:alice@10.129.161.35 SIP/2.0
Contact: <sip:alice@10.129.161.35:端口>
收到响应: 200
```

### 3. 检查INVITE转发
```
发送INVITE到 bob
收到响应: 100  ← Kamailio收到
收到响应: 180  ← Bob收到并振铃
收到响应: 200  ← Bob接听
```

### 4. 检查RTP端口
```
本地音频端口: 10000
远程音频地址: 10.129.161.35:10002
✅ RTP音频接收器已启动: 端口 10000
✅ RTP音频发送器已启动: /10.129.161.35:10002
```

### 5. 检查防火墙规则
```powershell
# Windows防火墙
New-NetFirewallRule -DisplayName "SIP UDP 5060" -Direction Inbound -Protocol UDP -LocalPort 5060 -Action Allow
New-NetFirewallRule -DisplayName "RTP UDP 10000-20000" -Direction Inbound -Protocol UDP -LocalPort 10000-20000 -Action Allow
```

---

## 最佳实践

### 1. 开发环境配置
- 使用固定IP地址，避免动态IP变化
- Kamailio和客户端在同一网络环境
- 关闭不必要的防火墙规则（开发阶段）

### 2. 错误处理
- 所有SIP操作添加try-catch
- 详细的日志输出（包含时间戳、用户名、操作类型）
- 使用emoji图标区分日志级别（✅❌⚠️📞）

### 3. 资源管理
- 每次通话前调用`stopStreams()`
- 使用`synchronized`确保端口分配唯一性
- 及时关闭不使用的网络连接

### 4. 测试流程
1. 重启所有组件（Kamailio、Server、Client）
2. 按顺序启动
3. 等待每个组件完全就绪
4. 先测试简单功能（注册、消息）
5. 再测试复杂功能（音视频通话）

---

## 常见问题速查

| 错误代码 | 含义 | 常见原因 | 解决方案 |
|---------|------|---------|---------|
| 100 | Trying | Kamailio收到请求 | 正常，等待后续响应 |
| 180 | Ringing | 对方振铃 | 正常，等待对方接听 |
| 200 | OK | 成功 | 正常 |
| 404 | Not Found | 用户未注册 | 检查对方是否在线 |
| 408 | Request Timeout | 请求超时 | 重启Kamailio或等待注册过期 |
| 486 | Busy Here | 对方忙碌 | 稍后再试 |
| 487 | Request Terminated | 请求被取消 | 用户主动挂断 |

---

## 工具和命令

### Maven命令
```bash
# 编译整个项目
mvn clean install -DskipTests

# 只编译客户端
cd sip-client && mvn clean compile

# 运行客户端
mvn javafx:run

# 打包服务器
cd sip-server && mvn clean package
```

### Docker命令
```bash
# 查看容器状态
docker ps -a

# 重启Kamailio
docker restart kamailio

# 查看Kamailio日志
docker logs -f kamailio

# 进入Kamailio容器
docker exec -it kamailio bash
```

### Windows进程管理
```powershell
# 查找Java进程
Get-Process | Where-Object {$_.ProcessName -eq "java"}

# 强制结束所有Java进程
taskkill /F /IM java.exe

# 查看端口占用
netstat -ano | findstr :5060
netstat -ano | findstr :10000
```

---

## 项目成功运行的标志

### ✅ 服务器正常运行
```
Started SipServerApplication in 3.456 seconds
Hikari connection pool started
WebSocket broker started
```

### ✅ 客户端成功注册
```
=== 客户端SIP监听端口: 7987 ===
发送REGISTER请求到 sip:alice@10.129.161.35
收到响应: 200
注册成功
```

### ✅ 通话成功建立
```
发送INVITE到 bob
收到响应: 100
收到响应: 180
收到响应: 200
✅ 真实RTP音频流已启动！
```

### ✅ 音视频正常传输
```
✅ RTP音频接收器已启动: 端口 10000
✅ RTP音频发送器已启动: /10.129.161.35:10002
✅ RTP视频接收器已启动: 端口 10004
✅ RTP视频发送器已启动: /10.129.161.35:10006
```

---

## 联系与支持

如遇到其他问题，请提供以下信息：
1. 完整的错误日志（包含时间戳）
2. SIP日志文件（siplog_xxx.txt, sipserver_xxx.txt）
3. 网络环境描述（IP地址、防火墙设置）
4. Kamailio版本和配置
5. 操作系统版本

---

**文档版本：** 1.0  
**最后更新：** 2025-10-20  
**状态：** 已验证可用

